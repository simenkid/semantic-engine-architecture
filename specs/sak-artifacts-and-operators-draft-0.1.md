# SAK Artifacts and Operators (Contracts) (Draft 0.1)

**Boundary:** This document defines artifact kinds and operator contracts (I/O, invariants, traceability). It does **not** define pack manifests or platform adapters.

## 1. Purpose

SAK defines portable artifacts and reproducible operator contracts for producing, evolving, and exporting a Self Model.

This file provides:
- **Artifact kinds** (what can be exchanged)
- **Operator contracts** (what can be invoked)

## 2. Artifact Kinds

### 2.1 SD_LOG (Reference)

Semantic Dynamics logs describing semantic motion over time. Source spec: *Semantic Dynamics*.

### 2.2 RD (Rhythm Descriptor) (Reference)

A descriptive artifact generated by Discovery Engine. Source spec: *Discovery Engine*.

**Important:** RD is descriptive/observational. It may contain fields such as `tension_signature` (statistical summary). It is **not** a user Profile.

### 2.3 SELF_MODEL

A portable cognitive specification as defined by `self-model-spec.md`.

A SELF_MODEL artifact MUST be semantically equivalent to:
- `core`
- `enrich.profile`
- `enrich.extensions[]`

Whether Profile/Extensions are embedded or referenced is a packaging decision.

### 2.4 EXTENSION (Optional standalone)

If Extensions are distributed independently, they MAY be represented as standalone artifacts and then composed into a Self Model at export time.

## 3. Common Metadata (Required)

All artifacts MUST carry minimal metadata:

- `id`: stable identifier
- `kind`: one of {SD_LOG, RD, SELF_MODEL, EXTENSION, ...}
- `version`: artifact version
- `created_at`: timestamp
- `provenance`:
  - `source_artifacts[]` (ids/versions)
  - `toolchain` (producer identity/version)
- `data_scope`: declared applicability scope (when meaningful)
- `data_quality`: producer-declared quality indicators (when meaningful)

## 4. Operator Contracts (Core Set)

Contracts define behavior, not implementation.

### 4.1 `compile_self_model`

**Goal:** Produce an initial SELF_MODEL from inputs.

- Inputs:
  - `inputs[]`: SD_LOG and/or RD and/or user-authored statements
  - optional `constraints`
- Output:
  - `self_model` (SELF_MODEL)
- Invariants:
  - MUST produce a semantically valid Self Model per `self-model-spec.md`
  - MUST attach provenance linking to all inputs used

### 4.2 `enrich_self_model`

**Goal:** Propose or apply enrichments without rewriting Core semantics.

- Inputs:
  - `base_model` (SELF_MODEL)
  - `enrich_inputs[]` (RD subsets, user edits, templates)
  - `mode`: {propose, apply}
- Output:
  - if `propose`: `patch` (see 4.3)
  - if `apply`: `new_model` (SELF_MODEL)
- Invariants:
  - MUST NOT violate Core invariants
  - MUST preserve rollbackability (see 4.4)

### 4.3 `merge_patch`

**Goal:** Merge a patch into a base model to produce a new version.

- Inputs:
  - `base_model` (SELF_MODEL)
  - `patch` (implementation-defined structure, but MUST be diffable)
- Output:
  - `new_model` (SELF_MODEL)
  - `diff_summary` (human-readable)
- Invariants:
  - MUST be deterministic given the same inputs
  - MUST emit a diff summary describing semantic changes

### 4.4 `rollback_version`

**Goal:** Revert to a previous model version.

- Inputs:
  - `model_id`
  - `target_version`
- Output:
  - `self_model` (SELF_MODEL)
- Invariants:
  - MUST restore prior semantics exactly
  - MUST preserve provenance history (do not erase history)

### 4.5 `export_self_model`

**Goal:** Project a SELF_MODEL into a target runtime representation.

- Inputs:
  - `self_model` (SELF_MODEL)
  - `export_scope` (declared scope/classifier)
  - `target`: {generic_prompt, platform_adapter_ref, ...}
- Output:
  - `export_bundle` (text/config; implementation-defined)
- Invariants:
  - MUST preserve Core invariants
  - MUST include only intended Enrich elements for `export_scope`
  - SHOULD minimize verbosity while maintaining fidelity

## 5. Traceability and Audit

A compliant implementation MUST:
- be able to explain which inputs influenced which Enrich elements (at least at artifact-level),
- provide diff summaries for merges,
- attach provenance to all generated artifacts.

## 6. Non-Goals

- Standardizing a single patch format across all implementations.
- Defining platform-specific adapters (belongs to portability docs).
